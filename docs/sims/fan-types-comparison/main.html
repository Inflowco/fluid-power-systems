<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fan Types Comparison</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, Helvetica, sans-serif;
            background: #f5f5f5;
            overflow-x: hidden;
        }
        #controls {
            background: #fff;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid #ddd;
            gap: 16px;
            flex-wrap: wrap;
        }
        #controls h2 {
            font-size: 18px;
            color: #333;
            margin: 0;
        }
        #compareBtn {
            background: #1565C0;
            color: #fff;
            border: none;
            padding: 8px 18px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }
        #compareBtn:hover { background: #0D47A1; }
        #compareBtn.active { background: #E65100; }
        #canvas-container { width: 100%; }
        #detail-panel {
            display: none;
            background: #fff;
            margin: 0 12px 12px 12px;
            padding: 16px 20px;
            border-radius: 6px;
            border: 2px solid #1565C0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        #detail-panel h3 { color: #1565C0; margin-bottom: 8px; font-size: 16px; }
        #detail-panel p { color: #444; font-size: 14px; line-height: 1.5; margin-bottom: 4px; }
        #comparison-table {
            display: none;
            margin: 0 12px 12px 12px;
            overflow-x: auto;
        }
        #comparison-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            background: #fff;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        #comparison-table th {
            background: #1565C0;
            color: #fff;
            padding: 10px 8px;
            text-align: center;
            font-weight: 600;
        }
        #comparison-table td {
            padding: 8px;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
            color: #333;
        }
        #comparison-table tr:nth-child(even) { background: #f8f9fa; }
        #comparison-table tr:hover { background: #e3f2fd; }
        .cat-centrifugal { background: #e3f2fd !important; }
        .cat-axial { background: #e8f5e9 !important; }
    </style>
</head>
<body>
    <div id="controls">
        <h2>Fan Types Comparison</h2>
        <button id="compareBtn" onclick="toggleCompare()">Compare All</button>
    </div>
    <div id="canvas-container"><main></main></div>
    <div id="detail-panel">
        <h3 id="detail-title"></h3>
        <p id="detail-text"></p>
    </div>
    <div id="comparison-table">
        <table>
            <thead>
                <tr>
                    <th>Property</th>
                    <th>Forward-Curved</th>
                    <th>Backward-Curved</th>
                    <th>Radial</th>
                    <th>Propeller</th>
                    <th>Tubeaxial</th>
                    <th>Vaneaxial</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Category</strong></td>
                    <td class="cat-centrifugal">Centrifugal</td>
                    <td class="cat-centrifugal">Centrifugal</td>
                    <td class="cat-centrifugal">Centrifugal</td>
                    <td class="cat-axial">Axial</td>
                    <td class="cat-axial">Axial</td>
                    <td class="cat-axial">Axial</td>
                </tr>
                <tr>
                    <td><strong>Efficiency</strong></td>
                    <td>60-65%</td>
                    <td>80-85%</td>
                    <td>55-65%</td>
                    <td>55-65%</td>
                    <td>65-72%</td>
                    <td>75-85%</td>
                </tr>
                <tr>
                    <td><strong>Pressure</strong></td>
                    <td>Low-Medium</td>
                    <td>Medium-High</td>
                    <td>Medium-High</td>
                    <td>Very Low</td>
                    <td>Low-Medium</td>
                    <td>Medium</td>
                </tr>
                <tr>
                    <td><strong>Noise Level</strong></td>
                    <td>Low</td>
                    <td>Low-Medium</td>
                    <td>High</td>
                    <td>Medium-High</td>
                    <td>Medium</td>
                    <td>Medium</td>
                </tr>
                <tr>
                    <td><strong>Self-Cleaning</strong></td>
                    <td>Poor</td>
                    <td>Good</td>
                    <td>Excellent</td>
                    <td>N/A</td>
                    <td>Fair</td>
                    <td>Fair</td>
                </tr>
                <tr>
                    <td><strong>Best Application</strong></td>
                    <td>HVAC, clean air</td>
                    <td>Industrial process</td>
                    <td>Material handling</td>
                    <td>General ventilation</td>
                    <td>Duct ventilation</td>
                    <td>Industrial ducting</td>
                </tr>
            </tbody>
        </table>
    </div>

    <script>
    // ══════════════════════════════════════════════════════════════════
    //  FAN DATA
    // ══════════════════════════════════════════════════════════════════
    const fans = [
        {
            name: 'Forward-Curved',
            category: 'Centrifugal',
            efficiency: '60-65%',
            effColor: 'yellow',
            pressure: 'Low-Medium',
            noise: 'Low',
            selfClean: 'Poor',
            bestApp: 'HVAC systems, clean air handling',
            description: 'Forward-curved centrifugal fans have many small blades that curve in the direction of rotation. They produce high airflow at low speeds, making them quiet and compact. Common in residential and commercial HVAC systems. Their small blade passages can clog with dirty air, so they are best suited for clean air applications.'
        },
        {
            name: 'Backward-Curved',
            category: 'Centrifugal',
            efficiency: '80-85%',
            effColor: 'green',
            pressure: 'Medium-High',
            noise: 'Low-Medium',
            selfClean: 'Good',
            bestApp: 'Industrial process air, AHUs',
            description: 'Backward-curved (or backward-inclined) fans have blades angled away from the direction of rotation. They are the most efficient centrifugal type, with a non-overloading power curve. Widely used in air handling units, industrial ventilation, and process applications where energy efficiency matters.'
        },
        {
            name: 'Radial',
            category: 'Centrifugal',
            efficiency: '55-65%',
            effColor: 'red',
            pressure: 'Medium-High',
            noise: 'High',
            selfClean: 'Excellent',
            bestApp: 'Material handling, dust-laden air',
            description: 'Radial (paddle-wheel) fans have flat straight blades extending from the hub. Though less efficient, their open blade design is self-cleaning and can handle particulate-laden, hot, or corrosive airstreams. Common in material handling, industrial exhaust, and dust collection systems.'
        },
        {
            name: 'Propeller',
            category: 'Axial',
            efficiency: '55-65%',
            effColor: 'red',
            pressure: 'Very Low',
            noise: 'Medium-High',
            selfClean: 'N/A',
            bestApp: 'General ventilation, cooling',
            description: 'Propeller fans are the simplest axial type, with blades mounted on a hub without a surrounding duct. They move large volumes of air against very low static pressure. Used for general ventilation in warehouses, rooftop exhaust, condenser cooling, and agricultural applications.'
        },
        {
            name: 'Tubeaxial',
            category: 'Axial',
            efficiency: '65-72%',
            effColor: 'yellow',
            pressure: 'Low-Medium',
            noise: 'Medium',
            selfClean: 'Fair',
            bestApp: 'Duct ventilation, exhaust systems',
            description: 'Tubeaxial fans mount a propeller inside a cylindrical housing (tube). The housing improves efficiency and allows connection to ductwork. Used for exhaust systems, paint booth ventilation, drying ovens, and general industrial ducted ventilation.'
        },
        {
            name: 'Vaneaxial',
            category: 'Axial',
            efficiency: '75-85%',
            effColor: 'green',
            pressure: 'Medium',
            noise: 'Medium',
            selfClean: 'Fair',
            bestApp: 'Industrial ducting, mine ventilation',
            description: 'Vaneaxial fans add guide vanes (straightening vanes) downstream of the impeller inside a cylindrical housing. The vanes recover rotational energy from the swirling airflow, significantly improving efficiency and pressure capability. Used in subway ventilation, mine ventilation, and industrial process ducting.'
        }
    ];

    // ══════════════════════════════════════════════════════════════════
    //  GLOBAL STATE
    // ══════════════════════════════════════════════════════════════════
    let canvasW, canvasH;
    let gridW, gridH;
    let cellW, cellH;
    let panelBoxes = [];
    let hoveredPanel = -1;
    let selectedPanel = -1;
    let showCompare = false;
    let animAngle = 0;
    let airflowOffset = 0;
    let sf = 1; // scale factor

    // Tooltip state
    let tooltipData = null;

    function setup() {
        calcSize();
        let canvas = createCanvas(canvasW, canvasH);
        canvas.parent(document.querySelector('main'));
        textFont('Arial');
    }

    function calcSize() {
        canvasW = min(windowWidth, 960);
        // 2x3 grid with some padding
        cellW = canvasW / 3;
        cellH = max(200, min(260, canvasW / 3.2));
        canvasH = cellH * 2 + 8; // 8px for row gap/labels
        sf = canvasW / 780;
    }

    function windowResized() {
        calcSize();
        resizeCanvas(canvasW, canvasH);
    }

    // ══════════════════════════════════════════════════════════════════
    //  MAIN DRAW
    // ══════════════════════════════════════════════════════════════════
    function draw() {
        background(245);
        animAngle += 0.02;
        airflowOffset += 1.5;

        panelBoxes = [];
        hoveredPanel = -1;
        tooltipData = null;

        for (let i = 0; i < 6; i++) {
            let col = i % 3;
            let row = floor(i / 3);
            let x = col * cellW;
            let y = row * cellH + (row === 1 ? 4 : 0);

            panelBoxes.push({ x, y, w: cellW, h: cellH, idx: i });

            // Check hover
            if (mouseX >= x && mouseX < x + cellW && mouseY >= y && mouseY < y + cellH) {
                hoveredPanel = i;
            }

            drawFanPanel(x, y, cellW, cellH, i, i === hoveredPanel, i === selectedPanel);
        }

        // Draw tooltip last (on top)
        if (tooltipData) {
            drawTooltip(tooltipData.x, tooltipData.y, tooltipData.fan);
        }
    }

    // ══════════════════════════════════════════════════════════════════
    //  DRAW FAN PANEL
    // ══════════════════════════════════════════════════════════════════
    function drawFanPanel(x, y, w, h, idx, isHovered, isSelected) {
        let fan = fans[idx];
        let isCentrifugal = idx < 3;

        push();

        // Background tint
        let bgColor = isCentrifugal ? color(33, 150, 243, 22) : color(76, 175, 80, 22);
        if (isHovered) {
            bgColor = isCentrifugal ? color(33, 150, 243, 45) : color(76, 175, 80, 45);
        }

        // Panel background
        noStroke();
        fill(bgColor);
        rect(x + 2, y + 2, w - 4, h - 4, 6);

        // Selected border
        if (isSelected) {
            noFill();
            stroke(isCentrifugal ? color(21, 101, 192) : color(46, 125, 50));
            strokeWeight(3);
            rect(x + 2, y + 2, w - 4, h - 4, 6);
        }

        // Panel border
        noFill();
        stroke(isCentrifugal ? color(33, 150, 243, 80) : color(76, 175, 80, 80));
        strokeWeight(1);
        rect(x + 2, y + 2, w - 4, h - 4, 6);

        // Category label at top
        noStroke();
        fill(isCentrifugal ? color(21, 101, 192) : color(46, 125, 50));
        textAlign(CENTER, TOP);
        textSize(max(9, 10 * sf));
        textStyle(NORMAL);
        text(isCentrifugal ? 'CENTRIFUGAL' : 'AXIAL', x + w / 2, y + 6);

        // Fan name
        fill(40);
        textSize(max(12, 14 * sf));
        textStyle(BOLD);
        text(fan.name, x + w / 2, y + 20);
        textStyle(NORMAL);

        // Draw the fan cross-section
        let diagCx = x + w / 2;
        let diagCy = y + h * 0.48;
        let diagSize = min(w, h) * 0.42;

        drawFanDiagram(diagCx, diagCy, diagSize, idx);

        // Draw airflow arrows
        drawAirflowArrows(diagCx, diagCy, diagSize, idx, isCentrifugal);

        // Efficiency badge
        drawEfficiencyBadge(x + w - 44 * sf, y + h - 28 * sf, fan.efficiency, fan.effColor, sf);

        // Tooltip on hover
        if (isHovered) {
            tooltipData = { x: mouseX, y: mouseY, fan: fan };
        }

        pop();
    }

    // ══════════════════════════════════════════════════════════════════
    //  FAN DIAGRAMS
    // ══════════════════════════════════════════════════════════════════
    function drawFanDiagram(cx, cy, size, idx) {
        push();
        translate(cx, cy);
        let r = size * 0.45;

        switch (idx) {
            case 0: drawForwardCurved(r); break;
            case 1: drawBackwardCurved(r); break;
            case 2: drawRadialFan(r); break;
            case 3: drawPropellerFan(r); break;
            case 4: drawTubeaxialFan(r); break;
            case 5: drawVaneaxialFan(r); break;
        }
        pop();
    }

    // ── Forward-Curved Centrifugal ─────────────────────────────────
    function drawForwardCurved(r) {
        // Scroll housing
        drawScrollHousing(r);

        // Many small forward-curved blades
        let numBlades = 16;
        let bladeR = r * 0.65;
        let innerR = r * 0.35;
        stroke(120, 130, 150);
        strokeWeight(max(1.5, 2 * sf));
        noFill();
        for (let i = 0; i < numBlades; i++) {
            let a = animAngle + (TWO_PI / numBlades) * i;
            let x1 = cos(a) * innerR;
            let y1 = sin(a) * innerR;
            // Blade curves forward (in direction of rotation)
            let tipA = a + 0.4; // curve forward
            let x2 = cos(tipA) * bladeR;
            let y2 = sin(tipA) * bladeR;
            let mx = cos(a + 0.2) * (innerR + bladeR) * 0.5;
            let my = sin(a + 0.2) * (innerR + bladeR) * 0.5;
            beginShape();
            vertex(x1, y1);
            quadraticVertex(mx + cos(a + HALF_PI) * 3, my + sin(a + HALF_PI) * 3, x2, y2);
            endShape();
        }

        // Hub
        drawHub(r * 0.22);
    }

    // ── Backward-Curved Centrifugal ────────────────────────────────
    function drawBackwardCurved(r) {
        drawScrollHousing(r);

        // Fewer backward-curved blades
        let numBlades = 8;
        let bladeR = r * 0.68;
        let innerR = r * 0.25;
        stroke(120, 130, 150);
        strokeWeight(max(2, 2.5 * sf));
        noFill();
        for (let i = 0; i < numBlades; i++) {
            let a = animAngle + (TWO_PI / numBlades) * i;
            let x1 = cos(a) * innerR;
            let y1 = sin(a) * innerR;
            // Blade angles backward (opposite to rotation direction)
            let tipA = a - 0.35;
            let x2 = cos(tipA) * bladeR;
            let y2 = sin(tipA) * bladeR;
            let mx = cos(a - 0.15) * (innerR + bladeR) * 0.52;
            let my = sin(a - 0.15) * (innerR + bladeR) * 0.52;
            beginShape();
            vertex(x1, y1);
            quadraticVertex(mx - cos(a + HALF_PI) * 4, my - sin(a + HALF_PI) * 4, x2, y2);
            endShape();
        }

        drawHub(r * 0.18);
    }

    // ── Radial (Paddle) Fan ────────────────────────────────────────
    function drawRadialFan(r) {
        drawScrollHousing(r);

        // Flat straight radial blades
        let numBlades = 6;
        let bladeR = r * 0.65;
        let innerR = r * 0.22;
        stroke(120, 130, 150);
        strokeWeight(max(2.5, 3 * sf));
        for (let i = 0; i < numBlades; i++) {
            let a = animAngle + (TWO_PI / numBlades) * i;
            let x1 = cos(a) * innerR;
            let y1 = sin(a) * innerR;
            let x2 = cos(a) * bladeR;
            let y2 = sin(a) * bladeR;
            line(x1, y1, x2, y2);
        }

        drawHub(r * 0.16);
    }

    // ── Propeller Fan (open, no housing) ───────────────────────────
    function drawPropellerFan(r) {
        // No housing -- just mounting ring (dashed circle)
        noFill();
        stroke(150);
        strokeWeight(1);
        drawingContext.setLineDash([4, 4]);
        circle(0, 0, r * 2.1);
        drawingContext.setLineDash([]);

        // Wide propeller blades
        let numBlades = 4;
        let bladeR = r * 0.85;
        let innerR = r * 0.18;
        for (let i = 0; i < numBlades; i++) {
            let a = animAngle * 1.3 + (TWO_PI / numBlades) * i;
            fill(180, 195, 210, 180);
            stroke(120, 130, 150);
            strokeWeight(max(1, 1.5 * sf));
            beginShape();
            let w = 0.25; // blade width angle
            vertex(cos(a - w * 0.3) * innerR, sin(a - w * 0.3) * innerR);
            vertex(cos(a - w) * bladeR * 0.7, sin(a - w) * bladeR * 0.7);
            vertex(cos(a) * bladeR, sin(a) * bladeR);
            vertex(cos(a + w * 0.5) * bladeR * 0.7, sin(a + w * 0.5) * bladeR * 0.7);
            vertex(cos(a + w * 0.3) * innerR, sin(a + w * 0.3) * innerR);
            endShape(CLOSE);
        }

        drawHub(r * 0.14);
    }

    // ── Tubeaxial Fan ──────────────────────────────────────────────
    function drawTubeaxialFan(r) {
        // Cylindrical tube housing
        fill(200, 210, 220, 60);
        stroke(130, 140, 160);
        strokeWeight(max(2, 2.5 * sf));
        rectMode(CENTER);
        rect(0, 0, r * 2.2, r * 2.0, 4);

        // Propeller blades inside tube
        let numBlades = 5;
        let bladeR = r * 0.78;
        let innerR = r * 0.16;
        for (let i = 0; i < numBlades; i++) {
            let a = animAngle * 1.2 + (TWO_PI / numBlades) * i;
            fill(180, 195, 210, 180);
            stroke(120, 130, 150);
            strokeWeight(max(1, 1.5 * sf));
            beginShape();
            let w = 0.2;
            vertex(cos(a - w * 0.3) * innerR, sin(a - w * 0.3) * innerR);
            vertex(cos(a - w) * bladeR * 0.65, sin(a - w) * bladeR * 0.65);
            vertex(cos(a) * bladeR, sin(a) * bladeR);
            vertex(cos(a + w * 0.4) * bladeR * 0.65, sin(a + w * 0.4) * bladeR * 0.65);
            vertex(cos(a + w * 0.3) * innerR, sin(a + w * 0.3) * innerR);
            endShape(CLOSE);
        }

        drawHub(r * 0.12);

        // Tube label
        noStroke();
        fill(100);
        textSize(max(8, 9 * sf));
        textAlign(CENTER, CENTER);
        text('Tube', r * 1.0, -r * 0.88);
    }

    // ── Vaneaxial Fan ──────────────────────────────────────────────
    function drawVaneaxialFan(r) {
        // Cylindrical tube housing - longer to show vane section
        fill(200, 210, 220, 60);
        stroke(130, 140, 160);
        strokeWeight(max(2, 2.5 * sf));
        rectMode(CENTER);
        rect(0, 0, r * 2.6, r * 2.0, 4);

        // Divider line between impeller and vane sections
        stroke(130, 140, 160, 120);
        strokeWeight(1);
        drawingContext.setLineDash([3, 3]);
        line(r * 0.3, -r * 0.98, r * 0.3, r * 0.98);
        drawingContext.setLineDash([]);

        // Impeller section (left side)
        push();
        translate(-r * 0.3, 0);
        let numBlades = 5;
        let bladeR = r * 0.72;
        let innerR = r * 0.14;
        for (let i = 0; i < numBlades; i++) {
            let a = animAngle * 1.2 + (TWO_PI / numBlades) * i;
            fill(180, 195, 210, 180);
            stroke(120, 130, 150);
            strokeWeight(max(1, 1.5 * sf));
            beginShape();
            let w = 0.2;
            vertex(cos(a - w * 0.3) * innerR, sin(a - w * 0.3) * innerR);
            vertex(cos(a - w) * bladeR * 0.65, sin(a - w) * bladeR * 0.65);
            vertex(cos(a) * bladeR, sin(a) * bladeR);
            vertex(cos(a + w * 0.4) * bladeR * 0.65, sin(a + w * 0.4) * bladeR * 0.65);
            vertex(cos(a + w * 0.3) * innerR, sin(a + w * 0.3) * innerR);
            endShape(CLOSE);
        }
        drawHub(r * 0.1);
        pop();

        // Guide vanes (right side, stationary)
        push();
        translate(r * 0.55, 0);
        let numVanes = 7;
        let vaneR = r * 0.7;
        let vaneInner = r * 0.12;
        stroke(100, 120, 160);
        strokeWeight(max(2, 2.5 * sf));
        noFill();
        for (let i = 0; i < numVanes; i++) {
            let a = (TWO_PI / numVanes) * i;
            let x1 = cos(a) * vaneInner;
            let y1 = sin(a) * vaneInner;
            let x2 = cos(a + 0.15) * vaneR;
            let y2 = sin(a + 0.15) * vaneR;
            line(x1, y1, x2, y2);
        }
        // Vane hub
        fill(140, 150, 170);
        stroke(100, 110, 130);
        strokeWeight(1.5);
        circle(0, 0, r * 0.2);
        pop();

        // Labels
        noStroke();
        fill(100);
        textSize(max(7, 8 * sf));
        textAlign(CENTER, CENTER);
        text('Impeller', -r * 0.3, -r * 0.88);
        text('Guide Vanes', r * 0.55, -r * 0.88);
    }

    // ══════════════════════════════════════════════════════════════════
    //  SHARED DRAWING HELPERS
    // ══════════════════════════════════════════════════════════════════

    function drawScrollHousing(r) {
        // Volute/scroll housing for centrifugal fans
        fill(200, 210, 220, 80);
        stroke(130, 140, 160);
        strokeWeight(max(2, 2.5 * sf));

        // Draw scroll shape
        beginShape();
        for (let a = 0; a <= TWO_PI; a += 0.05) {
            let rr = r * 0.82 + (a / TWO_PI) * r * 0.2;
            vertex(cos(a) * rr, sin(a) * rr);
        }
        endShape(CLOSE);

        // Inlet eye (center circle)
        fill(230, 240, 250, 100);
        stroke(130, 140, 160);
        strokeWeight(1);
        circle(0, 0, r * 0.55);

        // Discharge opening at top-right
        fill(200, 210, 220);
        stroke(130, 140, 160);
        strokeWeight(max(1.5, 2 * sf));
        rectMode(CORNER);
        rect(r * 0.6, -r * 0.2, r * 0.5, r * 0.28, 0, 3, 3, 0);
    }

    function drawHub(hubR) {
        fill(150, 155, 165);
        stroke(110, 115, 125);
        strokeWeight(max(1, 1.5 * sf));
        circle(0, 0, hubR * 2);
        fill(120);
        noStroke();
        circle(0, 0, hubR * 0.6);
    }

    // ══════════════════════════════════════════════════════════════════
    //  AIRFLOW ARROWS
    // ══════════════════════════════════════════════════════════════════
    function drawAirflowArrows(cx, cy, size, idx, isCentrifugal) {
        push();
        translate(cx, cy);
        let r = size * 0.45;

        stroke(isCentrifugal ? color(21, 101, 192, 180) : color(46, 125, 50, 180));
        fill(isCentrifugal ? color(21, 101, 192, 180) : color(46, 125, 50, 180));
        strokeWeight(max(1.5, 2 * sf));

        if (isCentrifugal) {
            // Centrifugal: air enters axially (from left into eye), exits tangentially (right)
            // Inlet arrow (left into center)
            let phase = (airflowOffset % 40) / 40;
            let arrowStartX = -r * 1.3 + phase * r * 0.3;
            drawArrow(arrowStartX, 0, -r * 0.4, 0, max(5, 6 * sf));
            let arrowStartX2 = -r * 1.3 + ((phase + 0.5) % 1) * r * 0.3;
            drawArrow(arrowStartX2, 0, -r * 0.4, 0, max(5, 6 * sf));

            // Outlet arrow (right from discharge)
            let outPhase = (airflowOffset % 35) / 35;
            let arrowOutX = r * 0.85 + outPhase * r * 0.4;
            drawArrow(r * 0.85, -r * 0.06, arrowOutX + r * 0.3, -r * 0.06, max(5, 6 * sf));
        } else {
            // Axial: air flows straight through (left to right)
            let numArrows = 3;
            for (let i = 0; i < numArrows; i++) {
                let yOff = (i - 1) * r * 0.55;
                let phase = ((airflowOffset + i * 15) % 50) / 50;

                if (idx === 3) {
                    // Propeller: wider spread, air goes through open blades
                    let startX = -r * 1.2 + phase * r * 0.5;
                    drawArrow(startX, yOff, startX + r * 0.6, yOff, max(5, 6 * sf));
                    // Exit side
                    let exitX = r * 0.6 + phase * r * 0.5;
                    drawArrow(exitX, yOff, exitX + r * 0.5, yOff, max(5, 6 * sf));
                } else if (idx === 4) {
                    // Tubeaxial: arrows in the tube
                    let startX = -r * 1.3 + phase * r * 0.5;
                    drawArrow(startX, yOff * 0.8, startX + r * 0.6, yOff * 0.8, max(5, 6 * sf));
                    let exitX = r * 0.5 + phase * r * 0.5;
                    drawArrow(exitX, yOff * 0.8, exitX + r * 0.6, yOff * 0.8, max(5, 6 * sf));
                } else {
                    // Vaneaxial: arrows showing straightened flow after vanes
                    let startX = -r * 1.6 + phase * r * 0.5;
                    // Before impeller: slightly angled
                    drawArrow(startX, yOff * 0.8, startX + r * 0.5, yOff * 0.8, max(5, 6 * sf));
                    // After vanes: straightened
                    let exitX = r * 0.8 + phase * r * 0.5;
                    drawArrow(exitX, yOff * 0.7, exitX + r * 0.55, yOff * 0.7, max(5, 6 * sf));
                }
            }
        }
        pop();
    }

    function drawArrow(x1, y1, x2, y2, headSize) {
        line(x1, y1, x2, y2);
        let a = atan2(y2 - y1, x2 - x1);
        push();
        translate(x2, y2);
        rotate(a);
        noStroke();
        triangle(0, 0, -headSize, -headSize * 0.4, -headSize, headSize * 0.4);
        pop();
    }

    // ══════════════════════════════════════════════════════════════════
    //  EFFICIENCY BADGE
    // ══════════════════════════════════════════════════════════════════
    function drawEfficiencyBadge(x, y, label, colorName, s) {
        let bg, fg;
        if (colorName === 'green') {
            bg = color(46, 125, 50); fg = color(255);
        } else if (colorName === 'yellow') {
            bg = color(245, 180, 0); fg = color(50);
        } else {
            bg = color(211, 47, 47); fg = color(255);
        }

        let badgeW = max(52, 56 * s);
        let badgeH = max(18, 20 * s);
        noStroke();
        fill(bg);
        rectMode(CENTER);
        rect(x, y, badgeW, badgeH, badgeH / 2);
        fill(fg);
        textSize(max(9, 10 * s));
        textAlign(CENTER, CENTER);
        textStyle(BOLD);
        text(label, x, y);
        textStyle(NORMAL);
    }

    // ══════════════════════════════════════════════════════════════════
    //  TOOLTIP
    // ══════════════════════════════════════════════════════════════════
    function drawTooltip(tx, ty, fan) {
        let lines = [
            'Efficiency: ' + fan.efficiency,
            'Pressure: ' + fan.pressure,
            'Noise: ' + fan.noise,
            'Self-Cleaning: ' + fan.selfClean,
            'Best For: ' + fan.bestApp
        ];

        textSize(max(11, 12 * sf));
        let lineH = max(16, 18 * sf);
        let maxW = 0;
        for (let l of lines) {
            maxW = max(maxW, textWidth(l));
        }
        let tipW = maxW + 24 * sf;
        let tipH = lines.length * lineH + 16 * sf;

        // Title height
        let titleH = lineH + 4;
        let totalH = titleH + tipH;

        // Position
        let tipX = tx + 14;
        let tipY = ty - totalH - 8;
        if (tipX + tipW > canvasW) tipX = canvasW - tipW - 8;
        if (tipY < 0) tipY = ty + 20;
        if (tipX < 4) tipX = 4;

        // Shadow
        noStroke();
        fill(0, 0, 0, 40);
        rect(tipX + 3, tipY + 3, tipW, totalH, 6);

        // Title bar
        fill(fan.category === 'Centrifugal' ? color(21, 101, 192) : color(46, 125, 50));
        rect(tipX, tipY, tipW, titleH, 6, 6, 0, 0);
        fill(255);
        textAlign(LEFT, CENTER);
        textStyle(BOLD);
        textSize(max(12, 13 * sf));
        text(fan.name, tipX + 10, tipY + titleH / 2);
        textStyle(NORMAL);

        // Body
        fill(40, 40, 50, 235);
        rect(tipX, tipY + titleH, tipW, tipH, 0, 0, 6, 6);
        fill(240);
        textSize(max(11, 12 * sf));
        textAlign(LEFT, TOP);
        for (let i = 0; i < lines.length; i++) {
            // Highlight the label part
            let colonIdx = lines[i].indexOf(':');
            let label = lines[i].substring(0, colonIdx + 1);
            let value = lines[i].substring(colonIdx + 1);
            fill(180, 210, 255);
            text(label, tipX + 10, tipY + titleH + 8 + i * lineH);
            fill(255);
            text(value, tipX + 10 + textWidth(label), tipY + titleH + 8 + i * lineH);
        }
        textAlign(CENTER, CENTER);
    }

    // ══════════════════════════════════════════════════════════════════
    //  MOUSE INTERACTION
    // ══════════════════════════════════════════════════════════════════
    function mousePressed() {
        for (let box of panelBoxes) {
            if (mouseX >= box.x && mouseX < box.x + box.w &&
                mouseY >= box.y && mouseY < box.y + box.h) {
                if (selectedPanel === box.idx) {
                    selectedPanel = -1;
                    document.getElementById('detail-panel').style.display = 'none';
                } else {
                    selectedPanel = box.idx;
                    showDetailPanel(box.idx);
                }
                return;
            }
        }
    }

    function showDetailPanel(idx) {
        let fan = fans[idx];
        let panel = document.getElementById('detail-panel');
        let isCentrifugal = idx < 3;
        panel.style.display = 'block';
        panel.style.borderColor = isCentrifugal ? '#1565C0' : '#2E7D32';
        document.getElementById('detail-title').textContent = fan.name + ' (' + fan.category + ')';
        document.getElementById('detail-title').style.color = isCentrifugal ? '#1565C0' : '#2E7D32';
        document.getElementById('detail-text').textContent = fan.description;
    }

    // ══════════════════════════════════════════════════════════════════
    //  COMPARE ALL TOGGLE
    // ══════════════════════════════════════════════════════════════════
    function toggleCompare() {
        showCompare = !showCompare;
        let btn = document.getElementById('compareBtn');
        let table = document.getElementById('comparison-table');
        if (showCompare) {
            btn.textContent = 'Hide Comparison';
            btn.classList.add('active');
            table.style.display = 'block';
        } else {
            btn.textContent = 'Compare All';
            btn.classList.remove('active');
            table.style.display = 'none';
        }
    }
    </script>
</body>
</html>
